pub fn string_dsa_examples(){

    /* Many of the same operations available with Vec<T> are available with String as well, because String is actually implemented as a wrapper around a vector of bytes with some extra guarantees, restrictions, and capabilities. */

    //create an instance of string.
    let mut s = String::new();


    /* Often, we’ll have some initial data that we want to start the string with. For that, we use the to_string method */

    let data = "initial data";
    let _initial_string = data.to_string();
    // or let initial_string = "initial data".to_string();

    //We can also use the function String::from to create a String from a string literal.
    let _ss = String::from("string literal");


    //updating string values.
    /* A String can grow in size and its contents can change, just like the contents of a Vec<T>, 
        if you push more data into it. In addition,
     you can conveniently use the + operator or the format! macro to concatenate String values. */

     //We can grow a String by using the push_str method to append a string slice,
    println!("{s}");
    s.push_str("bar");
    println!("{s}");

    let mut s1 = String::from("foo");
    let s2 = "bar";
    s1.push_str(s2);
    println!("s1 is {s1}");

    //The push method takes a single character as a parameter and adds it to the String. 

    s1.push('s');
    println!("s1 after push {s1}");


    //concatenation with the + Operator or format! Macro.
    let s3 = s1 + &s2;
    println!("s3 here {s3} s1 will lose it's ownership because value of s1 is moved. but s2 still available in scope because of taking as a reference");

    //another easy method to concate is using a format! Macro.
    let fs = format!("{s3}-{s2}");
    println!("{fs}");
    //The version of the code using format! is much easier to read, and the code generated by the format! macro uses references so that this call doesn’t take ownership of any of its parameters.


    //we cannot access each index using indexing in string

    //methods for iterating over strings.
    for c in fs.chars(){
        println!("{c}");
    }

    //alternatively bytes method.
    for b in fs.bytes(){
        println!("{b}");
    }





}